/*
 * Copyright (C) 1996 - 2001 BULL
 * Copyright (C) 1996 - 2001 INRIA
 *
 * The contents of this file are subject to the Joram Public License,
 * as defined by the file JORAM_LICENSE.TXT 
 * 
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License on the Objectweb web site
 * (www.objectweb.org). 
 * 
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
 * the specific terms governing rights and limitations under the License. 
 * 
 * The Original Code is Joram, including the java packages fr.dyade.aaa.agent,
 * fr.dyade.aaa.util, fr.dyade.aaa.ip, fr.dyade.aaa.mom, fr.dyade.aaa.jndi 
 * and fr.dyade.aaa.joram, released October, 2001. 
 * 
 * The Initial Developer of the Original Code is Dyade. The Original Code and
 * portions created by Dyade are Copyright Bull and Copyright INRIA.
 * All Rights Reserved.
 */
//----------------------------------------------------
// The following code was generated by CUP v0.10j
// Fri Sep 07 11:06:57 CEST 2001
//----------------------------------------------------

package fr.dyade.aaa.mom.selectors;

/** Cup generated class to encapsulate user supplied action code.*/
public class CUPcheckParseractions {
  private final checkParser parser;

  /** Constructor */
  CUPcheckParseractions(checkParser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final Symbol CUPcheckParserdo_action(
    int                        CUPcheckParseract_num,
    lr_parser CUPcheckParserparser,
    java.util.Stack            CUPcheckParserstack,
    int                        CUPcheckParsertop)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      Symbol CUPcheckParserresult;

      /* select the action based on the action number */
      switch (CUPcheckParseract_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // lit_expr ::= BOOLEAN 
            {
              Object RESULT = null;
		int boolleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int boolright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Boolean bool = (Boolean)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  RESULT = bool;
                
              CUPcheckParserresult = new Symbol(5/*lit_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // lit_expr ::= STRING 
            {
              Object RESULT = null;
		int stleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int stright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		String st = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  RESULT = st.substring(1, st.length() - 1);
                
              CUPcheckParserresult = new Symbol(5/*lit_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // lit_expr ::= DOUBLE 
            {
              Object RESULT = null;
		int dbleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int dbright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Double db = (Double)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  RESULT = db;
                
              CUPcheckParserresult = new Symbol(5/*lit_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // lit_expr ::= ID 
            {
              Object RESULT = null;
		int idleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int idright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		String id = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  // id type and value are not known at that step!
                  RESULT = null;
                
              CUPcheckParserresult = new Symbol(5/*lit_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // lit_expr ::= LPAREN expr RPAREN 
            {
              Object RESULT = null;
		int eleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-1)).left;
		int eright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-1)).right;
		Object e = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-1)).value;
		
                  RESULT = e;
                
              CUPcheckParserresult = new Symbol(5/*lit_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // expr ::= lit_expr 
            {
              Object RESULT = null;
		int litleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int litright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Object lit = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  RESULT = lit;
                
              CUPcheckParserresult = new Symbol(4/*expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // expr ::= MINUS expr 
            {
              Object RESULT = null;
		int eleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int eright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Object e = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  if (e instanceof String || e instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected after '-'");
                  else 
                    RESULT = new Double(0);
                
              CUPcheckParserresult = new Symbol(4/*expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-1)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // expr ::= PLUS expr 
            {
              Object RESULT = null;
		int eleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int eright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Object e = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  if (e instanceof String || e instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected after '+'");
                  else 
                    RESULT = new Double(0);
                
              CUPcheckParserresult = new Symbol(4/*expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-1)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // expr ::= expr DIVIDE expr 
            {
              Object RESULT = null;
		int e1left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left;
		int e1right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).right;
		Object e1 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).value;
		int e2left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int e2right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Object e2 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  if (e1 instanceof String || e1 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected before '/'");
                  else if (e2 instanceof String || e2 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected after '/'");
                  else 
                    RESULT = new Double(0);
                
              CUPcheckParserresult = new Symbol(4/*expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // expr ::= expr TIMES expr 
            {
              Object RESULT = null;
		int e1left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left;
		int e1right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).right;
		Object e1 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).value;
		int e2left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int e2right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Object e2 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  if (e1 instanceof String || e1 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected before '*'");
                  else if (e2 instanceof String || e2 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected after '*'");
                  else 
                    RESULT = new Double(0);
                
              CUPcheckParserresult = new Symbol(4/*expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // expr ::= expr MINUS expr 
            {
              Object RESULT = null;
		int e1left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left;
		int e1right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).right;
		Object e1 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).value;
		int e2left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int e2right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Object e2 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  if (e1 instanceof String || e1 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected before '-'");
                  else if (e2 instanceof String || e2 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected after '-'");
                  else 
                    RESULT = new Double(0);
                
              CUPcheckParserresult = new Symbol(4/*expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // expr ::= expr PLUS expr 
            {
              Object RESULT = null;
		int e1left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left;
		int e1right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).right;
		Object e1 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).value;
		int e2left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int e2right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Object e2 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  if (e1 instanceof String || e1 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected before '+'");
                  else if (e2 instanceof String || e2 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected after '+'");
                  else 
                    RESULT = new Double(0);
                
              CUPcheckParserresult = new Symbol(4/*expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // strings ::= STRING 
            {
              String RESULT = null;
		int stleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int stright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		String st = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  RESULT = st.substring(1, st.length() - 1);
                
              CUPcheckParserresult = new Symbol(3/*strings*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // strings ::= strings COMMA STRING 
            {
              String RESULT = null;
		int stsleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left;
		int stsright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).right;
		String sts = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).value;
		int stleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int stright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		String st = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  RESULT = sts + st.substring(1, st.length() - 1);
                
              CUPcheckParserresult = new Symbol(3/*strings*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // comp_expr ::= expr 
            {
              Boolean RESULT = null;
		int eleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int eright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Object e = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  if (e instanceof String || e instanceof Double)
                    throw new javax.jms.InvalidSelectorException(
                      "Boolean type expected");
                  RESULT = new Boolean("TRUE");
                
              CUPcheckParserresult = new Symbol(2/*comp_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // comp_expr ::= ID IS NOT NULL 
            {
              Boolean RESULT = null;
		int idleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-3)).left;
		int idright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-3)).right;
		String id = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-3)).value;
		
                  RESULT = new Boolean("TRUE");
                
              CUPcheckParserresult = new Symbol(2/*comp_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-3)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // comp_expr ::= ID IS NULL 
            {
              Boolean RESULT = null;
		int idleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left;
		int idright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).right;
		String id = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).value;
		
                  RESULT = new Boolean("TRUE");
                
              CUPcheckParserresult = new Symbol(2/*comp_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // comp_expr ::= ID NOT LIKE STRING ESCAPE STRING 
            {
              Boolean RESULT = null;
		int idleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-5)).left;
		int idright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-5)).right;
		String id = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-5)).value;
		int st1left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left;
		int st1right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).right;
		String st1 = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).value;
		int st2left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int st2right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		String st2 = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  // id type can't be checked at that point!
                  RESULT = new Boolean("TRUE");
                
              CUPcheckParserresult = new Symbol(2/*comp_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-5)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // comp_expr ::= ID LIKE STRING ESCAPE STRING 
            {
              Boolean RESULT = null;
		int idleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-4)).left;
		int idright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-4)).right;
		String id = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-4)).value;
		int st1left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left;
		int st1right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).right;
		String st1 = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).value;
		int st2left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int st2right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		String st2 = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  // id type can't be checked at that point!
                  RESULT = new Boolean("TRUE");
                
              CUPcheckParserresult = new Symbol(2/*comp_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-4)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // comp_expr ::= ID NOT LIKE STRING 
            {
              Boolean RESULT = null;
		int idleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-3)).left;
		int idright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-3)).right;
		String id = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-3)).value;
		int stleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int stright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		String st = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  // id type can't be checked at that point!
                  RESULT = new Boolean("TRUE");
                
              CUPcheckParserresult = new Symbol(2/*comp_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-3)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // comp_expr ::= ID LIKE STRING 
            {
              Boolean RESULT = null;
		int idleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left;
		int idright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).right;
		String id = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).value;
		int stleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int stright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		String st = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  // id type can't be checked at that point!
                  RESULT = new Boolean("TRUE");
                
              CUPcheckParserresult = new Symbol(2/*comp_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // comp_expr ::= ID NOT IN LPAREN strings RPAREN 
            {
              Boolean RESULT = null;
		int idleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-5)).left;
		int idright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-5)).right;
		String id = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-5)).value;
		int stsleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-1)).left;
		int stsright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-1)).right;
		String sts = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-1)).value;
		
                  // id type can't be checked at that point!
                  RESULT = new Boolean("TRUE");
                
              CUPcheckParserresult = new Symbol(2/*comp_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-5)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // comp_expr ::= ID IN LPAREN strings RPAREN 
            {
              Boolean RESULT = null;
		int idleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-4)).left;
		int idright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-4)).right;
		String id = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-4)).value;
		int stsleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-1)).left;
		int stsright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-1)).right;
		String sts = (String)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-1)).value;
		
                  // id type can't be checked at that point!
                  RESULT = new Boolean("TRUE");
                
              CUPcheckParserresult = new Symbol(2/*comp_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-4)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // comp_expr ::= expr NOTBETWEEN expr AND expr 
            {
              Boolean RESULT = null;
		int e1left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-4)).left;
		int e1right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-4)).right;
		Object e1 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-4)).value;
		int e2left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left;
		int e2right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).right;
		Object e2 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).value;
		int e3left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int e3right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Object e3 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  if (e1 instanceof String || e1 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected before 'NOT BETWEEN'");
                  else if (e2 instanceof String || e2 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected after 'BETWEEN'");
                  else if (e3 instanceof String || e3 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected after 'AND'");
                  else
                    RESULT = new Boolean("TRUE");
                
              CUPcheckParserresult = new Symbol(2/*comp_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-4)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // comp_expr ::= expr BETWEEN expr AND expr 
            {
              Boolean RESULT = null;
		int e1left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-4)).left;
		int e1right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-4)).right;
		Object e1 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-4)).value;
		int e2left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left;
		int e2right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).right;
		Object e2 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).value;
		int e3left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int e3right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Object e3 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  if (e1 instanceof String || e1 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected before 'BETWEEN'");
                  else if (e2 instanceof String || e2 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected after 'BETWEEN'");
                  else if (e3 instanceof String || e3 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected after 'AND'");
                  else
                    RESULT = new Boolean("TRUE");
                
              CUPcheckParserresult = new Symbol(2/*comp_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-4)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // comp_expr ::= expr NEQ expr 
            {
              Boolean RESULT = null;
		int e1left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left;
		int e1right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).right;
		Object e1 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).value;
		int e2left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int e2right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Object e2 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  RESULT = new Boolean("TRUE");
                
              CUPcheckParserresult = new Symbol(2/*comp_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // comp_expr ::= expr EQ expr 
            {
              Boolean RESULT = null;
		int e1left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left;
		int e1right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).right;
		Object e1 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).value;
		int e2left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int e2right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Object e2 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  RESULT = new Boolean("TRUE");
                
              CUPcheckParserresult = new Symbol(2/*comp_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // comp_expr ::= expr LE expr 
            {
              Boolean RESULT = null;
		int e1left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left;
		int e1right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).right;
		Object e1 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).value;
		int e2left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int e2right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Object e2 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  if (e1 instanceof String || e1 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected before '<='");
                  else if (e2 instanceof String || e2 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected after '<='");
                  else
                    RESULT = new Boolean("TRUE");
                
              CUPcheckParserresult = new Symbol(2/*comp_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // comp_expr ::= expr LT expr 
            {
              Boolean RESULT = null;
		int e1left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left;
		int e1right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).right;
		Object e1 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).value;
		int e2left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int e2right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Object e2 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  if (e1 instanceof String || e1 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected before '<'");
                  else if (e2 instanceof String || e2 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected after '<'");
                  else
                    RESULT = new Boolean("TRUE");
                
              CUPcheckParserresult = new Symbol(2/*comp_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // comp_expr ::= expr GE expr 
            {
              Boolean RESULT = null;
		int e1left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left;
		int e1right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).right;
		Object e1 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).value;
		int e2left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int e2right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Object e2 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  if (e1 instanceof String || e1 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected before '>='");
                  else if (e2 instanceof String || e2 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected after '>='");
                  else
                    RESULT = new Boolean("TRUE");
                
              CUPcheckParserresult = new Symbol(2/*comp_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // comp_expr ::= expr GT expr 
            {
              Boolean RESULT = null;
		int e1left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left;
		int e1right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).right;
		Object e1 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).value;
		int e2left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int e2right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Object e2 = (Object)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  if (e1 instanceof String || e1 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected before '>'");
                  else if (e2 instanceof String || e2 instanceof Boolean)
                    throw new javax.jms.InvalidSelectorException(
                      "Numeric type expected after '>'");
                  else
                    RESULT = new Boolean("TRUE");
                
              CUPcheckParserresult = new Symbol(2/*comp_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // comp_expr ::= LPAREN cond_expr RPAREN 
            {
              Boolean RESULT = null;
		int condleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-1)).left;
		int condright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-1)).right;
		Boolean cond = (Boolean)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-1)).value;
		
                  RESULT = cond;
                
              CUPcheckParserresult = new Symbol(2/*comp_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // cond_expr ::= comp_expr 
            {
              Boolean RESULT = null;
		int compleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int compright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Boolean comp = (Boolean)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  RESULT = comp;
                
              CUPcheckParserresult = new Symbol(1/*cond_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // cond_expr ::= NOT cond_expr 
            {
              Boolean RESULT = null;
		int condleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int condright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Boolean cond = (Boolean)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  RESULT = new Boolean(! cond.booleanValue());
                
              CUPcheckParserresult = new Symbol(1/*cond_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-1)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // cond_expr ::= cond_expr AND cond_expr 
            {
              Boolean RESULT = null;
		int cond1left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left;
		int cond1right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).right;
		Boolean cond1 = (Boolean)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).value;
		int cond2left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int cond2right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Boolean cond2 = (Boolean)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  RESULT = new Boolean(cond1.booleanValue() &&
                                       cond2.booleanValue());
                
              CUPcheckParserresult = new Symbol(1/*cond_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= cond_expr EOF 
            {
              Object RESULT = null;
		int start_valleft = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-1)).left;
		int start_valright = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-1)).right;
		Boolean start_val = (Boolean)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-1)).value;
		RESULT = start_val;
              CUPcheckParserresult = new Symbol(0/*$START*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-1)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          /* ACCEPT */
          CUPcheckParserparser.done_parsing();
          return CUPcheckParserresult;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // cond_expr ::= cond_expr OR cond_expr 
            {
              Boolean RESULT = null;
		int cond1left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left;
		int cond1right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).right;
		Boolean cond1 = (Boolean)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).value;
		int cond2left = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).left;
		int cond2right = ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right;
		Boolean cond2 = (Boolean)((Symbol) CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).value;
		
                  // Using AND instead of OR so that
                  // both cond1 and cond2 are checked.
                  RESULT = new Boolean(cond1.booleanValue() &&
                                       cond2.booleanValue());
                
              CUPcheckParserresult = new Symbol(1/*cond_expr*/, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-2)).left, ((Symbol)CUPcheckParserstack.elementAt(CUPcheckParsertop-0)).right, RESULT);
            }
          return CUPcheckParserresult;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

